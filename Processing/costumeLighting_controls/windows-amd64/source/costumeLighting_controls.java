/* autogenerated by Processing revision 1301 on 2025-04-15 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import controlP5.*;
import ch.bildspur.artnet.*;
import ch.bildspur.artnet.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class costumeLighting_controls extends PApplet {

/*
 * LED Costume Controller - Processing Control Interface
 * ------------------------------------------
 * 
 * This code provides a graphical interface to control two NeoPixel LED strips via Art-Net:
 * 1. A badge (8x4 grid, 32 LEDs)
 * 2. A collar (30 LEDs by default, configurable)
 * 
 * The interface allows for:
 * - Setting colors and animations for both LED sets independently
 * - Adjusting brightness, speed, and animation parameters
 * - Connecting to ESP32 devices over WiFi using Art-Net protocol
 * 
 * Hardware Requirements:
 * - Computer running Processing
 * - ESP32 device running the companion receiver sketch
 * - WiFi network connecting both devices
 * 
 * Libraries Required:
 * - ControlP5: https://github.com/sojamo/controlp5
 * - ArtnetP5: https://github.com/rstephan/ArtnetP5
 * 
 * Settings to Change:
 * - Default device IP address if needed
 * - Default LED counts and effects if desired
 * 
 */




// Global variables
ControlP5 cp5;
Grid ledGrid;
Strip ledStrip;
boolean initialized = false;

// Animation timer to track elapsed time for animations
long startTime;

// Currently selected effects and playback modes
String gridEffect = "pulse";
String stripEffect = "pulse";
String gridPlayback = "loop";
String stripPlayback = "loop";

// Current colors
int gridStartColor = 0xFFFF00FF; // Default magenta
int gridEndColor = 0xFF00FFFF;   // Default cyan
int stripStartColor = 0xFFFF0000; // Default red
int stripEndColor = 0xFF0000FF;   // Default blue

// Speed values
float gridSpeed = 1.0f;
float stripSpeed = 0.5f;

// Strip LED count
int stripCount = 30;

// Linear fade angle for grid
float gridLinearAngle = 0;

// ArtNet settings
ArtNetDevice artnetDevice;
String deviceIP = "192.168.1.100";  // Default IP address from the Arduino code
int universe = 0;                    // Default universe (hardcoded now)
boolean artNetEnabled = true;        // Enable/disable ArtNet sending
boolean isConnected = false;         // Track connection status

// LED Brightness (0-255)
int ledBrightness = 50;  // Default value matching Arduino code

// Frame timing
int lastFrameTime = 0;
int targetFPS = 30;  // Default target FPS
int frameInterval = 1000/targetFPS;  // Frame interval in milliseconds

// Window dimensions
int windowWidth = 1080;    // Window width
int windowHeight = 1000;   // Window height

public void setup() {
  /* size commented out by preprocessor */;  // Window size
  background(245);
  
  // Initialize UI
  cp5 = new ControlP5(this);
  
  // Initialize LEDs - Grid must be initialized before Strip
  ledGrid = new Grid(8, 4);
  ledStrip = new Strip(stripCount);
  
  // Initialize UI controls - must be after LED initialization
  setupControls();
  
  // Apply styling to color wheels
  fixColorWheelStyling();
  
  // Initialize animation timer
  startTime = millis();
  
  // Initialize ArtNet device (badge = 32 LEDs, collar = 30 LEDs by default)
  if (artNetEnabled) {
    try {
      artnetDevice = new ArtNetDevice(universe, deviceIP, 32 + stripCount);
      println("ArtNet initialized: " + deviceIP + " on universe " + universe);
      isConnected = true;
      updateStatusLabel();
    } catch (Exception e) {
      println("Error initializing ArtNet: " + e.getMessage());
      artNetEnabled = false;
      isConnected = false;
      updateStatusLabel();
    }
  }
  
  initialized = true;
}

public void draw() {
  // Frame rate limiting for all updates (animation and ArtNet)
  int currentTime = millis();
  if (currentTime - lastFrameTime < frameInterval) {
    return;
  }
  lastFrameTime = currentTime;
  
  background(245);
  
  // Draw main container
  fill(255);
  stroke(0, 0, 0, 25);
  rect(20, 20, width-40, height-40, 8);
  
  // Update animations
  if (initialized) {
    // Update color values from the ColorWheels
    updateColorsFromWheels();
    
    ledGrid.update();
    ledStrip.update();
    
    // Draw the LED grid and strip
    ledGrid.display();
    ledStrip.display();
    
    // Send the LED data via ArtNet
    if (artNetEnabled && artnetDevice != null && isConnected) {
      artnetDevice.updateData(ledGrid.leds, ledStrip.leds, ledBrightness);
      artnetDevice.sendData();
    }
  }
}

// Reset the animation timer
public void resetAnimations() {
  startTime = millis();
  ledGrid.resetColors();
  ledStrip.resetColors();
}

// Update color values from ColorWheel components
public void updateColorsFromWheels() {
  // Get ColorWheels from ControlP5
  ColorWheel gridStartWheel = (ColorWheel) cp5.getController("gridStartColorWheel");
  ColorWheel gridEndWheel = (ColorWheel) cp5.getController("gridEndColorWheel");
  ColorWheel stripStartWheel = (ColorWheel) cp5.getController("stripStartColorWheel");
  ColorWheel stripEndWheel = (ColorWheel) cp5.getController("stripEndColorWheel");
  
  // Update color values if wheels are available
  if (gridStartWheel != null) {
    gridStartColor = gridStartWheel.getRGB();
  }
  
  if (gridEndWheel != null) {
    gridEndColor = gridEndWheel.getRGB();
  }
  
  if (stripStartWheel != null) {
    stripStartColor = stripStartWheel.getRGB();
  }
  
  if (stripEndWheel != null) {
    stripEndColor = stripEndWheel.getRGB();
  }
}

// Fix the styling of the ColorWheel components
public void fixColorWheelStyling() {
  // This function is now a placeholder since we're letting the ColorWheel handle its own layout
}

// Event handlers for controls
public void controlEvent(ControlEvent event) {
  // Handle UI events
  if (!event.isController()) return;
  
  String name = event.getController().getName();
  
  // Grid effect changed
  if (name.equals("gridEffect")) {
    gridEffect = cp5.get(ScrollableList.class, "gridEffect").getItem((int)event.getValue()).get("name").toString();
    resetAnimations();
  }
  // Grid playback changed
  else if (name.equals("gridPlayback")) {
    gridPlayback = cp5.get(ScrollableList.class, "gridPlayback").getItem((int)event.getValue()).get("name").toString();
    resetAnimations();
  }
  // Strip effect changed
  else if (name.equals("stripEffect")) {
    stripEffect = cp5.get(ScrollableList.class, "stripEffect").getItem((int)event.getValue()).get("name").toString();
    resetAnimations();
  }
  // Strip playback changed
  else if (name.equals("stripPlayback")) {
    stripPlayback = cp5.get(ScrollableList.class, "stripPlayback").getItem((int)event.getValue()).get("name").toString();
    resetAnimations();
  }
  // Strip count changed
  else if (name.equals("stripCount")) {
    stripCount = PApplet.parseInt(event.getController().getValue());
    ledStrip = new Strip(stripCount);
    // Recreate ArtNet device with new LED count
    if (artNetEnabled && isConnected) {
      connectArtNet();
    }
  }
  // Grid speed changed
  else if (name.equals("gridSpeed")) {
    gridSpeed = event.getController().getValue();
  }
  // Strip speed changed
  else if (name.equals("stripSpeed")) {
    stripSpeed = event.getController().getValue();
  }
  // Grid linear angle changed
  else if (name.equals("gridLinearAngle")) {
    gridLinearAngle = event.getController().getValue();
  }
  // Device IP changed
  else if (name.equals("deviceIP")) {
    deviceIP = cp5.get(Textfield.class, "deviceIP").getText();
  }
  // Connect button pressed
  else if (name.equals("connectArtNet")) {
    connectArtNet();
  }
  // Disconnect button pressed
  else if (name.equals("disconnectArtNet")) {
    disconnectArtNet();
  }
  // FPS changed
  else if (name.equals("targetFPS")) {
    targetFPS = PApplet.parseInt(event.getController().getValue());
    frameInterval = 1000/targetFPS;
  }
  // Brightness changed
  else if (name.equals("ledBrightness")) {
    ledBrightness = PApplet.parseInt(event.getController().getValue());
  }
}

// ArtNet connection methods
public void connectArtNet() {
  // Make sure we get the most current IP from the text field
  deviceIP = cp5.get(Textfield.class, "deviceIP").getText();
  
  // Clean up existing connection if any
  if (artnetDevice != null) {
    artnetDevice.stop();
    artnetDevice = null;
  }
  
  try {
    // Create a new ArtNet device with current settings and hardcoded universe 0
    artnetDevice = new ArtNetDevice(0, deviceIP, 32 + stripCount);
    artNetEnabled = true;
    isConnected = true;
    updateStatusLabel();
    println("Connected to ArtNet device at: " + deviceIP);
  } catch (Exception e) {
    println("Error connecting to ArtNet: " + e.getMessage());
    isConnected = false;
    artNetEnabled = false;
    updateStatusLabel();
  }
}

// Disconnect from ArtNet and turn off all LEDs
public void disconnectArtNet() {
  if (artnetDevice != null && artnetDevice.connected) {
    println("Starting disconnect sequence...");
    
    try {
      // Use the dedicated blackout method to turn off all LEDs
      artnetDevice.sendBlackout(ledBrightness);
      
      // Wait briefly to ensure data is sent
      delay(100);
      
      // Close the connection
      artnetDevice.stop();
      artnetDevice = null;
      isConnected = false;
      artNetEnabled = false;
      updateStatusLabel();
      println("Disconnected from ArtNet device at: " + deviceIP);
    } catch (Exception e) {
      println("Error during disconnection: " + e.getMessage());
    }
  }
}

// Update the host IP display if necessary
public void updateStatusLabel() {
  // We removed the status text from UI as requested
  // Update IP text color based on connection
  Textfield ipField = cp5.get(Textfield.class, "deviceIP");
  if (ipField != null) {
    if (isConnected) {
      // Add green highlight when connected
      ipField.setColorBackground(color(0, 65, 0));
    } else {
      // Default color when not connected
      ipField.setColorBackground(color(0, 45, 90));
    }
  }
}

// Clean shutdown - important for ArtNet
public void exit() {
  if (artnetDevice != null) {
    // Send blackout before exiting
    artnetDevice.sendBlackout(ledBrightness);
    delay(100);
    artnetDevice.stop();
  }
  super.exit();
}


class ArtNetDevice {
  ArtNetClient artnet;
  int universe;
  String deviceIP;
  boolean connected = false;
  
  // Buffer for combined data (badge + collar)
  byte[] combinedData;
  
  // First byte is reserved for brightness (added to the beginning of the data array)
  byte brightnessValue = 50; // Default brightness
  
  ArtNetDevice(int universe, String deviceIP, int totalLEDs) {
    this.universe = universe; // Always set to 0 now by the caller
    this.deviceIP = deviceIP;
    
    // Initialize the byte array to hold brightness byte + RGB data for all LEDs
    // Add 1 for the brightness byte
    combinedData = new byte[1 + totalLEDs * 3];
    
    // Set default brightness
    combinedData[0] = brightnessValue;
    
    // Initialize ArtNet client
    try {
      artnet = new ArtNetClient(null);
      artnet.start();
      connected = true;
      println("ArtNet client initialized. Sending to " + deviceIP + " on universe " + universe);
    } catch (Exception e) {
      println("Error initializing ArtNet client: " + e.getMessage());
      connected = false;
    }
  }
  
  // Update the data buffer with grid (badge) and strip (collar) LED colors and the brightness value
  public void updateData(LED[][] gridLEDs, LED[] stripLEDs, int brightness) {
    // Set brightness byte (first byte of the data)
    brightnessValue = (byte)brightness;
    combinedData[0] = brightnessValue;
    
    // Start index after brightness byte
    int index = 1;
    
    // First copy badge (grid) data - assuming 8x4 = 32 LEDs
    for (int y = 0; y < gridLEDs.length; y++) {
      for (int x = 0; x < gridLEDs[y].length; x++) {
        int c = gridLEDs[y][x].currentColor;
        
        // R, G, B values
        combinedData[index++] = (byte)((c >> 16) & 0xFF);  // Red
        combinedData[index++] = (byte)((c >> 8) & 0xFF);   // Green
        combinedData[index++] = (byte)(c & 0xFF);          // Blue
      }
    }
    
    // Then copy collar (strip) data
    for (int i = 0; i < stripLEDs.length; i++) {
      int c = stripLEDs[i].currentColor;
      
      // R, G, B values
      combinedData[index++] = (byte)((c >> 16) & 0xFF);  // Red
      combinedData[index++] = (byte)((c >> 8) & 0xFF);   // Green
      combinedData[index++] = (byte)(c & 0xFF);          // Blue
    }
  }
  
  // Special method to send all-black data (turn off all LEDs)
  public void sendBlackout(int brightness) {
    if (connected) {
      try {
        // Create a temporary all-black data array
        // Keep original array size (1 + total LED count * 3)
        byte[] blackoutData = new byte[combinedData.length];
        
        // Set the brightness byte
        blackoutData[0] = (byte)brightness;
        
        // All other bytes remain 0 (black)
        
        // Send the blackout data
        artnet.unicastDmx(deviceIP, universe, 0, blackoutData);
        println("Sent blackout data to universe " + universe);
        
        // Send it again to make sure it arrives
        delay(50);
        artnet.unicastDmx(deviceIP, universe, 0, blackoutData);
        println("Sent blackout data again");
      } catch (Exception e) {
        println("Error sending blackout data: " + e.getMessage());
        connected = false;
      }
    }
  }
  
  // Send the data via ArtNet
  public void sendData() {
    if (connected) {
      try {
        // Universe is always 0 now (hardcoded)
        artnet.unicastDmx(deviceIP, universe, 0, combinedData);
      } catch (Exception e) {
        println("Error sending ArtNet data: " + e.getMessage());
        connected = false;
      }
    }
  }
  
  // Close the ArtNet client properly
  public void stop() {
    if (artnet != null) {
      artnet.stop();
    }
  }
}
// ColorUtils.pde
// Utility functions for color manipulation

/**
 * Generates a random color between two colors
 * 
 * @param color1 First color
 * @param color2 Second color
 * @return Random color between color1 and color2
 */
public int randomColorBetween(int color1, int color2) {
  // Generate random factor between 0 and 1
  float factor = random(1);
  
  // Interpolate between the colors using Processing's lerpColor
  return lerpColor(color1, color2, factor);
}

/**
 * Converts HSV values to RGB color
 * 
 * @param h Hue (0-1)
 * @param s Saturation (0-1)
 * @param v Value/Brightness (0-1)
 * @return RGB color
 */
public int hsv2rgb(float h, float s, float v) {
  float r, g, b;
  
  // Implementation based on standard HSV to RGB algorithm
  int i = floor(h * 6);
  float f = h * 6 - i;
  float p = v * (1 - s);
  float q = v * (1 - f * s);
  float t = v * (1 - (1 - f) * s);
  
  // Calculate RGB values based on the sector of the HSV color wheel
  switch (i % 6) {
    case 0: r = v; g = t; b = p; break;
    case 1: r = q; g = v; b = p; break;
    case 2: r = p; g = v; b = t; break;
    case 3: r = p; g = q; b = v; break;
    case 4: r = t; g = p; b = v; break;
    case 5: r = v; g = p; b = q; break;
    default: r = 0; g = 0; b = 0; break;
  }
  
  // Convert back to 0-255 range
  return color(r * 255, g * 255, b * 255);
}

/**
 * Converts RGB color to HSV values
 * 
 * @param c RGB color
 * @return float array [h, s, v] with values 0-1
 */
public float[] rgb2hsv(int c) {
  float r = red(c) / 255.0f;
  float g = green(c) / 255.0f;
  float b = blue(c) / 255.0f;
  
  float max = max(r, max(g, b));
  float min = min(r, min(g, b));
  float delta = max - min;
  
  float h = 0, s = 0, v = max;
  
  // Calculate saturation (0 if completely unsaturated)
  s = max == 0 ? 0 : delta / max;
  
  // Calculate hue
  if (delta == 0) {
    h = 0; // achromatic (gray)
  } else {
    // Calculate hue based on which RGB component is maximum
    if (max == r) {
      h = (g - b) / delta + (g < b ? 6 : 0);
    } else if (max == g) {
      h = (b - r) / delta + 2;
    } else { // max == b
      h = (r - g) / delta + 4;
    }
    h /= 6; // Normalize to 0-1 range
  }
  
  return new float[] {h, s, v};
}
// Controls.pde
// Functions for setting up and managing UI controls

public void setupControls() {
  // Create Network Controls group at the top of the page
  setupNetworkControlGroup(40);
  
  // Calculate total height needed for LEDs to position controls below
  float ledsHeight = ledGrid.yPos + ledGrid.height + 10;
  
  // Add space for the LED strip (account for multiple rows)
  int maxLedsPerRow = (int) Math.floor((windowWidth - 100) / (ledStrip.ledSize + ledStrip.spacing));
  int rowCount = (int) Math.ceil((float)stripCount / maxLedsPerRow);
  float stripHeight = rowCount * (ledStrip.ledSize + ledStrip.spacing) + 10;
  
  // Position brightness slider centered under the strip with more space
  setupBrightnessSlider(ledStrip.yPos + stripHeight + 20);
  
  // Position controls directly after the brightness slider - with MORE space
  float controlsY = ledStrip.yPos + stripHeight + 100; // Increased spacing
  
  // Create groups for grid and strip controls with proper spacing
  setupGridControlGroup(controlsY);
  setupStripControlGroup(controlsY);
  
  // Create debug group at the bottom - with more space and collapsible
  setupDebugGroup(controlsY + 450); // Moved further down
}

public void setupNetworkControlGroup(float yPos) {
  // Create a group for Network controls at the top
  Group networkGroup = cp5.addGroup("Network Controls")
    .setPosition(20, yPos)
    .setWidth(windowWidth - 40)
    .setBackgroundHeight(90) // Slightly taller to accommodate larger input
    .setBackgroundColor(color(240))
    .setBarHeight(25)
    .setColorBackground(color(60, 80, 120))
    .setColorLabel(color(255))
    .setColorActive(color(255, 128, 0))
    .disableCollapse()
    ;
    
  // IP address field - LARGER with bigger text and white text - fix flicker issue
  cp5.addTextfield("deviceIP")
     .setPosition(40, 40)
     .setSize(280, 40) // Larger size
     .setText(deviceIP)
     .setFont(createFont("Arial Bold", 18)) // Fixed font
     .setLabel("")  // Remove inline label to fix flicker
     .setLabelVisible(false) // Hide label during drawing
     .setColor(color(255)) // White text inside the box
     .setColorBackground(color(0, 45, 90))
     .setColorForeground(color(0, 55, 100))
     .setColorActive(color(0, 65, 120))
     .setGroup(networkGroup)
     .setAutoClear(false)
     ;
  
     
  // Connect button
  cp5.addButton("connectArtNet")
     .setPosition(340, 40)
     .setSize(100, 40) // Taller to match IP input
     .setLabel("CONNECT")
     .setFont(createFont("Arial", 14))
     .setColorBackground(color(0, 45, 90))
     .setColorForeground(color(0, 55, 100))
     .setColorActive(color(0, 65, 120))
     .setGroup(networkGroup)
     ;
     
  // Disconnect button - to the right of Connect button
  cp5.addButton("disconnectArtNet")
     .setPosition(450, 40)
     .setSize(120, 40) // Taller to match IP input, wider for text
     .setLabel("DISCONNECT")
     .setFont(createFont("Arial", 14))
     .setColorBackground(color(90, 45, 0)) // Different color to indicate caution
     .setColorForeground(color(100, 55, 0))
     .setColorActive(color(120, 65, 0))
     .setGroup(networkGroup)
     ;
  
  // Controller IP address display - now with larger text
  cp5.addTextlabel("hostIPDisplay")
     .setPosition(625, 50) // Vertically centered in the taller group
     .setFont(createFont("Arial Bold", 18)) // Increased font size and made bold
     .setText("CONTROLLER IP: " + getHostIP())
     .setColorValue(color(0))
     .setGroup(networkGroup)
     ;
}

public void setupBrightnessSlider(float yPos) {
  // Create a centered brightness slider with label position matching screenshot
  cp5.addSlider("ledBrightness")
     .setPosition((windowWidth - 400) / 2, yPos)
     .setSize(400, 20)
     .setRange(0, 255)
     .setValue(ledBrightness)
     .setLabelVisible(true)
     .setLabel("LED BRIGHTNESS")
     .setColorBackground(color(0, 45, 90))
     .setColorForeground(color(0, 55, 100))
     .setColorActive(color(0, 65, 120))
     .setColorLabel(color(0))
     .setColorValue(color(255))
     ;
  
  // Position the label below the slider centered
  Slider brightnessSlider = (Slider)cp5.getController("ledBrightness");
  brightnessSlider.getCaptionLabel()
                 .align(ControlP5.CENTER, ControlP5.BOTTOM_OUTSIDE)
                 .setPaddingY(5);
}

public void setupGridControlGroup(float yPos) {
  // Adjusted width to fit within narrower window with 5px margin
  int groupWidth = (windowWidth - 40) / 2 - 10;
  
  // Create a group for grid controls - matching screenshot style
  Group gridGroup = cp5.addGroup("Grid Controls")
    .setPosition(20, yPos)  
    .setWidth(groupWidth)
    .setBackgroundHeight(400)
    .setBackgroundColor(color(250))
    .setBarHeight(25)
    .setColorBackground(color(60, 60, 100))
    .setColorLabel(color(255))
    .setColorActive(color(255, 128, 0))
    .disableCollapse()
    ;
    
  // Keep original wheel size
  int wheelSize = PApplet.parseInt(groupWidth * 0.4f);
  
  // Original positions as per screenshot
  cp5.addColorWheel("gridStartColorWheel")
    .setPosition(30, 35)
    .setSize(wheelSize, wheelSize)
    .setRGB(gridStartColor)
    .setLabel("START COLOR")
    .setGroup(gridGroup)
    ;
    
  // End color wheel
  cp5.addColorWheel("gridEndColorWheel")
    .setPosition(wheelSize + 70, 35)
    .setSize(wheelSize, wheelSize)
    .setRGB(gridEndColor)
    .setLabel("END COLOR")
    .setGroup(gridGroup)
    ;
  
  int controlWidth = groupWidth - 40;
  int controlHalfWidth = (controlWidth - 20) / 2;
  
  // Effect dropdown - style matching screenshot
  cp5.addScrollableList("gridEffect")
    .setPosition(20, wheelSize + 45)
    .setSize(controlHalfWidth, 140)
    .setBarHeight(20)
    .setItemHeight(20)
    .addItems(java.util.Arrays.asList("none", "solid", "pulse", "linear", "constrainbow", "rainbow", "wipe"))
    .setValue(2) // Default to pulse (index 2)
    .setLabel("EFFECT")
    .setColorBackground(color(0, 45, 90))
    .setColorForeground(color(0, 55, 100))
    .setColorActive(color(0, 65, 120))
    .setGroup(gridGroup)
    ;
  
  // Linear fade angle slider - style matching screenshot
  cp5.addSlider("gridLinearAngle")
    .setPosition(controlHalfWidth + 40, wheelSize + 45)
    .setSize(controlHalfWidth, 20)
    .setRange(0, 360)
    .setValue(0)
    .setLabel("LINEAR FADE ANGLE")
    .setColorBackground(color(0, 45, 90))
    .setColorForeground(color(0, 55, 100))
    .setColorActive(color(0, 65, 120))
    .setColorLabel(color(0))
    .setColorValue(color(255))
    .setGroup(gridGroup)
    ;
    
  // Move label BELOW the slider (changed from top)
  Slider angleSlider = (Slider)cp5.getController("gridLinearAngle");
  angleSlider.getCaptionLabel()
           .align(ControlP5.LEFT, ControlP5.BOTTOM_OUTSIDE)
           .setPaddingY(5);
  
  // Speed slider - style matching screenshot
  cp5.addSlider("gridSpeed")
    .setPosition(controlHalfWidth + 40, wheelSize + 85)
    .setSize(controlHalfWidth, 20)
    .setRange(0.1f, 10)
    .setValue(1)
    .setLabel("SPEED")
    .setColorBackground(color(0, 45, 90))
    .setColorForeground(color(0, 55, 100))
    .setColorActive(color(0, 65, 120))
    .setColorLabel(color(0))
    .setColorValue(color(255))
    .setGroup(gridGroup)
    ;
    
  // Move label BELOW the slider (changed from top)
  Slider speedSlider = (Slider)cp5.getController("gridSpeed");
  speedSlider.getCaptionLabel()
           .align(ControlP5.LEFT, ControlP5.BOTTOM_OUTSIDE)
           .setPaddingY(5);
  
  // Playback mode dropdown - style matching screenshot
  cp5.addScrollableList("gridPlayback")
    .setPosition(controlHalfWidth + 40, wheelSize + 125)
    .setSize(controlHalfWidth, 100)
    .setBarHeight(20)
    .setItemHeight(20)
    .addItems(java.util.Arrays.asList("loop", "boomerang", "once"))
    .setValue(0) // Default to loop
    .setLabel("PLAYBACK MODE")
    .setColorBackground(color(0, 45, 90))
    .setColorForeground(color(0, 55, 100))
    .setColorActive(color(0, 65, 120))
    .setGroup(gridGroup)
    ;
}

public void setupStripControlGroup(float yPos) {
  // Adjusted width to fit within narrower window with 5px margin
  int groupWidth = (windowWidth - 40) / 2 - 10;
  
  // Create a group for strip controls - matching screenshot style
  Group stripGroup = cp5.addGroup("Strip Controls")
    .setPosition(windowWidth/2, yPos)
    .setWidth(groupWidth) 
    .setBackgroundHeight(400)
    .setBackgroundColor(color(240))
    .setBarHeight(25)
    .setColorBackground(color(100, 60, 100))
    .setColorLabel(color(255))
    .setColorActive(color(255, 128, 0))
    .disableCollapse()
    ;
    
  // Keep original wheel size
  int wheelSize = PApplet.parseInt(groupWidth * 0.4f);
  
  // Original positions, just closer to top
  cp5.addColorWheel("stripStartColorWheel")
    .setPosition(30, 35)
    .setSize(wheelSize, wheelSize)
    .setRGB(stripStartColor)
    .setLabel("START COLOR")
    .setGroup(stripGroup)
    ;
    
  // End color wheel
  cp5.addColorWheel("stripEndColorWheel")
    .setPosition(wheelSize + 70, 35)
    .setSize(wheelSize, wheelSize)
    .setRGB(stripEndColor)
    .setLabel("END COLOR")
    .setGroup(stripGroup)
    ;
  
  int controlWidth = groupWidth - 40;
  int controlHalfWidth = (controlWidth - 20) / 2;
  
  // Effect dropdown - style matching screenshot
  cp5.addScrollableList("stripEffect")
    .setPosition(20, wheelSize + 45)
    .setSize(controlHalfWidth, 140)
    .setBarHeight(20)
    .setItemHeight(20)
    .addItems(java.util.Arrays.asList("none", "solid", "pulse", "linear", "constrainbow", "rainbow", "wipe"))
    .setValue(2) // Default to pulse (index 2)
    .setLabel("EFFECT")
    .setColorBackground(color(0, 45, 90))
    .setColorForeground(color(0, 55, 100))
    .setColorActive(color(0, 65, 120))
    .setGroup(stripGroup)
    ;
  
  // LED count input - style matching screenshot
  cp5.addNumberbox("stripCount")
    .setPosition(controlHalfWidth + 40, wheelSize + 45)
    .setSize(controlHalfWidth, 20)
    .setRange(1, 300)
    .setValue(stripCount)
    .setMultiplier(1)
    .setDirection(Controller.HORIZONTAL)
    .setLabel("NUMBER OF LEDS")
    .setColorBackground(color(0, 45, 90))
    .setColorForeground(color(0, 55, 100))
    .setColorActive(color(0, 65, 120))
    .setColorLabel(color(0))
    .setColorValue(color(255))
    .setGroup(stripGroup)
    ;
    
  // Move label BELOW the control (changed from top)
  Numberbox countBox = (Numberbox)cp5.getController("stripCount");
  countBox.getCaptionLabel()
        .align(ControlP5.LEFT, ControlP5.BOTTOM_OUTSIDE)
        .setPaddingY(5);
  
  // Speed slider - style matching screenshot
  cp5.addSlider("stripSpeed")
    .setPosition(controlHalfWidth + 40, wheelSize + 85)
    .setSize(controlHalfWidth, 20)
    .setRange(0.1f, 10)
    .setValue(1.0f)
    .setLabel("SPEED")
    .setColorBackground(color(0, 45, 90))
    .setColorForeground(color(0, 55, 100))
    .setColorActive(color(0, 65, 120))
    .setColorLabel(color(0))
    .setColorValue(color(255))
    .setGroup(stripGroup)
    ;
    
  // Move label BELOW the slider (changed from top)  
  Slider stripSpeedSlider = (Slider)cp5.getController("stripSpeed");
  stripSpeedSlider.getCaptionLabel()
                .align(ControlP5.LEFT, ControlP5.BOTTOM_OUTSIDE)
                .setPaddingY(5);
  
  // Playback mode dropdown - style matching screenshot
  cp5.addScrollableList("stripPlayback")
    .setPosition(controlHalfWidth + 40, wheelSize + 125)
    .setSize(controlHalfWidth, 100)
    .setBarHeight(20)
    .setItemHeight(20)
    .addItems(java.util.Arrays.asList("loop", "boomerang", "once"))
    .setValue(0) // Default to loop
    .setLabel("PLAYBACK MODE")
    .setColorBackground(color(0, 45, 90))
    .setColorForeground(color(0, 55, 100))
    .setColorActive(color(0, 65, 120))
    .setGroup(stripGroup)
    ;
}

// Set up Debug group at the bottom - now collapsible and collapsed by default
public void setupDebugGroup(float yPos) {
  // Create a group for Debug - matching screenshot style, now collapsible
  Group debugGroup = cp5.addGroup("Debug")
    .setPosition((windowWidth - 400) / 2, yPos)
    .setWidth(400)
    .setBackgroundHeight(80)
    .setBackgroundColor(color(240))
    .setBarHeight(25)
    .setColorBackground(color(80, 80, 120))
    .setColorLabel(color(255))
    .setColorActive(color(255, 128, 0))
    .enableCollapse() // Make it collapsible
    .close() // Collapsed by default
    ;
  
  // FPS control slider - style matching screenshot
  cp5.addSlider("targetFPS")
     .setPosition(20, 10)
     .setSize(350, 20)
     .setRange(1, 60)
     .setValue(targetFPS)
     .setNumberOfTickMarks(12)
     .setLabel("TARGET FPS")
     .setColorBackground(color(0, 45, 90))
     .setColorForeground(color(0, 55, 100))
     .setColorActive(color(0, 65, 120))
     .setColorLabel(color(0))
     .setColorValue(color(255))
     .setGroup(debugGroup)
     ;
     
  // Left-align the label BELOW the slider (changed from top)
  Slider fpsSlider = (Slider)cp5.getController("targetFPS");
  fpsSlider.getCaptionLabel()
          .align(ControlP5.LEFT, ControlP5.BOTTOM_OUTSIDE)
          .setPaddingY(5);
}

// Utility function to get the host IP address
// Improved to work on both Windows and Mac OS
public String getHostIP() {
  try {
    // First try the getLocalHost approach (works well on Windows)
    String ip = java.net.InetAddress.getLocalHost().getHostAddress();
    
    // If we got the loopback address (127.0.0.1 or similar), try an alternative method
    if (ip.startsWith("127.")) {
      // Try to find a non-loopback IPv4 address (works better on Mac OS)
      java.util.Enumeration<java.net.NetworkInterface> interfaces = java.net.NetworkInterface.getNetworkInterfaces();
      while (interfaces.hasMoreElements()) {
        java.net.NetworkInterface networkInterface = interfaces.nextElement();
        // Skip loopback and inactive interfaces
        if (networkInterface.isLoopback() || !networkInterface.isUp()) {
          continue;
        }
        
        // Look through all IP addresses assigned to this interface
        java.util.Enumeration<java.net.InetAddress> addresses = networkInterface.getInetAddresses();
        while (addresses.hasMoreElements()) {
          java.net.InetAddress addr = addresses.nextElement();
          // Only consider IPv4 addresses that aren't loopback
          if (!addr.isLoopbackAddress() && addr instanceof java.net.Inet4Address) {
            return addr.getHostAddress();
          }
        }
      }
    }
    return ip; // Return the original IP if we couldn't find a better one
  } catch (Exception e) {
    println("Error getting IP address: " + e.getMessage());
    return "Unknown";
  }
}
// Class to manage the 8x4 grid of LEDs

class Grid {
  int cols, rows;
  LED[][] leds;
  float cellSize;
  
  // Position of the grid on screen
  float xPos = 50;
  float yPos = 150; // Moved down further to provide more space below network controls
  float width, height;
  
  Grid(int cols, int rows) {
    this.cols = cols;
    this.rows = rows;
    
    // Keep original cell size
    cellSize = 70;
    width = cols * cellSize;
    height = rows * cellSize;
    
    // Position grid in the center horizontally
    xPos = (windowWidth - width) / 2; // Center horizontally in the window
    
    // Create grid of LEDs
    leds = new LED[rows][cols];
    for (int y = 0; y < rows; y++) {
      for (int x = 0; x < cols; x++) {
        leds[y][x] = new LED(
          xPos + x * cellSize + cellSize/2, 
          yPos + y * cellSize + cellSize/2,
          cellSize * 0.8f
        );
      }
    }
  }
  
  public void display() {
    // Draw grid container
    fill(255);
    rect(xPos - 10, yPos - 10, width + 20, height + 20, 8);
    
    // Draw LEDs
    for (int y = 0; y < rows; y++) {
      for (int x = 0; x < cols; x++) {
        leds[y][x].display();
      }
    }
  }
  
  public void update() {
    // Calculate elapsed time in seconds adjusted by speed
    float elapsedSec = (millis() - startTime) / 1000.0f * gridSpeed;
    
    // Calculate animation progress factor based on playback mode
    float animFactor = 0;
    if (gridPlayback.equals("once")) {
      // For "once" mode, cap at 1.0 (100% complete)
      animFactor = min(elapsedSec * 0.2f, 1);
    } else if (gridPlayback.equals("boomerang")) {
      // For "boomerang" mode, go from 0 to 1 and back to 0
      float cycle = (elapsedSec * 0.2f) % 2;
      animFactor = cycle <= 1 ? cycle : 2 - cycle;
    } else {
      // For "loop" mode, cycle from 0 to 1 repeatedly
      animFactor = (elapsedSec * 0.2f) % 1;
    }
    
    // Update each LED in the grid
    for (int y = 0; y < rows; y++) {
      for (int x = 0; x < cols; x++) {
        updateLED(leds[y][x], x, y, animFactor, elapsedSec);
      }
    }
  }
  
  public void updateLED(LED led, int x, int y, float animFactor, float elapsedSec) {
    // Apply different effects based on selected effect
    switch (gridEffect) {
      case "none":
        // Turn all LEDs off (black)
        led.setColor(color(0));
        break;
        
      case "solid":
        // Solid color using start color
        led.setColor(gridStartColor);
        break;
        
      case "pulse":
        // Pulse between start and end colors using sine wave
        float pulseFactor = (sin(elapsedSec) + 1) / 2; // 0 to 1
        
        // Interpolate between start and end colors
        int pulseColor = lerpColor(gridStartColor, gridEndColor, pulseFactor);
        led.setColor(pulseColor);
        break;
        
      case "linear":
        // Linear fade effect based on angle
        float angle = radians(gridLinearAngle);
        
        // Normalize position to -0.5 to 0.5 range
        float nx = x / PApplet.parseFloat(cols - 1) - 0.5f;
        float ny = y / PApplet.parseFloat(rows - 1) - 0.5f;
        
        // Create offset based on animation factor
        float offsetX = cos(animFactor * TWO_PI) * 0.2f;
        float offsetY = sin(animFactor * TWO_PI) * 0.2f;
        
        // Calculate dot product for direction
        PVector angleVector = new PVector(cos(angle), sin(angle));
        float dotProduct = (nx + offsetX) * angleVector.x + (ny + offsetY) * angleVector.y;
        
        // Map to 0-1 range
        float linearFactor = constrain(dotProduct + 0.5f, 0, 1);
        
        // Interpolate between colors
        int linearColor = lerpColor(gridStartColor, gridEndColor, linearFactor);
        led.setColor(linearColor);
        break;
        
      case "constrainbow":
        // Update progress based on playback mode and speed
        if (gridPlayback.equals("once")) {
          // For "once" mode, cap progress at 1
          led.progress = min(led.progress + 0.01f * gridSpeed, 1);
        } else if (gridPlayback.equals("boomerang")) {
          // For "boomerang" mode, go back and forth
          float cyclePosition = (led.progress * 2) % 2;
          
          // Increment progress
          led.progress += 0.01f * gridSpeed;
          
          // Calculate interpolation factor based on cycle position
          float factor = cyclePosition < 1 ? cyclePosition : 2 - cyclePosition;
          
          // Interpolate RGB colors
          int interpColor = lerpColor(led.currentTargetColor, led.nextTargetColor, factor);
          led.setColor(interpColor);
          
          // If we've completed a full cycle, choose new colors
          if (led.progress >= 1) {
            int temp = led.currentTargetColor;
            led.currentTargetColor = led.nextTargetColor;
            led.nextTargetColor = randomColorBetween(gridStartColor, gridEndColor);
            led.progress = 0;
          }
          
          break;
        } else {
          // For "loop" mode, simply increment progress
          led.progress += 0.01f * gridSpeed;
        }
        
        // Check if we've reached the target
        if (led.progress >= 1) {
          // Choose new colors
          led.currentTargetColor = led.nextTargetColor;
          led.nextTargetColor = randomColorBetween(gridStartColor, gridEndColor);
          led.progress = 0;
        }
        
        // Interpolate RGB colors
        int constRainbowColor = lerpColor(led.currentTargetColor, led.nextTargetColor, led.progress);
        led.setColor(constRainbowColor);
        break;
        
      case "rainbow":
        // True rainbow effect: cycle through full RGB spectrum
        
        // Create an offset based on grid position for wave-like effect
        float rainbowOffset = (x / PApplet.parseFloat(cols) + y / PApplet.parseFloat(rows)) * 0.5f;
        
        // Calculate base hue from elapsed time and position
        float rainbowHue = (elapsedSec * 0.2f + rainbowOffset) % 1;
        
        // Apply playback mode modifier
        if (gridPlayback.equals("once")) {
          // Cap at 1.0 for 'once' mode
          rainbowHue = min(rainbowHue, 1);
        } else if (gridPlayback.equals("boomerang")) {
          // Make it go forward and backward
          int cycle = floor(rainbowHue);
          rainbowHue = cycle % 2 == 0 ? rainbowHue % 1 : 1 - (rainbowHue % 1);
        }
        
        // Convert HSV to RGB (using full saturation and value)
        int rainbowColor = hsv2rgb(rainbowHue, 1, 1);
        led.setColor(rainbowColor);
        break;
        
      case "wipe":
        // Wipe effect: transition from start to end color horizontally
        
        // In boomerang mode, we need to handle the return transition differently
        if (gridPlayback.equals("boomerang")) {
          // For boomerang, use the full cycle position (0-2)
          float fullCycle = (elapsedSec * 0.2f) % 2;
          
          // First half of cycle: 0->1 = start to end
          // Second half of cycle: 1->2 = end to start
          if (fullCycle <= 1) {
            // Forward transition (0->1)
            int wipeStep = ceil(fullCycle * cols);
            led.setColor(x < wipeStep ? gridEndColor : gridStartColor);
          } else {
            // Reverse transition (1->2)
            float reversePos = 2 - fullCycle; // Goes from 1->0
            int wipeStep = floor(reversePos * cols);
            led.setColor(x >= wipeStep ? gridStartColor : gridEndColor);
          }
        } else {
          // Standard wipe for loop and once modes
          int wipeStep = ceil(animFactor * cols);
          led.setColor(x < wipeStep ? gridEndColor : gridStartColor);
        }
        break;
    }
  }
  
  public void resetColors() {
    // Reset constrainbow colors for each LED
    for (int y = 0; y < rows; y++) {
      for (int x = 0; x < cols; x++) {
        leds[y][x].resetConstrainbowColors();
      }
    }
  }
}

// Class to represent a single LED in the system

class LED {
  float x, y;
  float size;
  int currentColor = 0xFF888888; // Default gray
  
  // For constrainbow effect
  int currentTargetColor;
  int nextTargetColor;
  float progress = 0;
  
  LED(float x, float y, float size) {
    this.x = x;
    this.y = y;
    this.size = size;
    
    // Initialize random colors for constrainbow
    resetConstrainbowColors();
  }
  
  public void display() {
    fill(currentColor);
    noStroke();
    ellipse(x, y, size, size);
  }
  
  public void setColor(int c) {
    currentColor = c;
  }
  
  public void resetConstrainbowColors() {
    // Reset colors used for constrainbow effect
    currentTargetColor = randomColorBetween(gridStartColor, gridEndColor);
    nextTargetColor = randomColorBetween(gridStartColor, gridEndColor);
    progress = 0;
  }
  
  // Returns the current LED color
  public int getColor() {
    return currentColor;
  }
}
// Class to manage the LED strip

class Strip {
  int count;
  LED[] leds;
  float ledSize = 20; // Keep original LED size
  float spacing = 5;  // Keep original spacing
  
  // Position of the strip on screen
  float xPos = 50;
  float yPos; // Will be set dynamically based on grid position
  float width;
  
  Strip(int count) {
    this.count = count;
    
    // Set yPos based on grid position (to be below grid)
    yPos = ledGrid.yPos + ledGrid.height + 30;
    
    // Calculate total width needed for all LEDs
    float totalWidth = (ledSize + spacing) * count;
    
    // Calculate how many LEDs we can fit per row based on windowWidth
    int maxLedsPerRow = (int) Math.floor((windowWidth - 100) / (ledSize + spacing));
    
    // Position strip centered horizontally
    xPos = (windowWidth - Math.min(totalWidth, maxLedsPerRow * (ledSize + spacing))) / 2;
    
    // Create array of LEDs
    leds = new LED[count];
    for (int i = 0; i < count; i++) {
      // Calculate row and column for this LED
      int row = i / maxLedsPerRow;
      int col = i % maxLedsPerRow;
      
      leds[i] = new LED(
        xPos + col * (ledSize + spacing) + ledSize/2,
        yPos + row * (ledSize + spacing) + ledSize/2,
        ledSize
      );
    }
    
    // Update width for display purposes
    width = Math.min(totalWidth, maxLedsPerRow * (ledSize + spacing));
  }
  
  public void display() {
    // Calculate how many rows we need
    int maxLedsPerRow = (int) Math.floor((windowWidth - 100) / (ledSize + spacing));
    int rowCount = (int) Math.ceil((float)count / maxLedsPerRow);
    
    // Draw strip container
    fill(255);
    
    // Container for the entire strip
    float containerHeight = rowCount * (ledSize + spacing) + 10;
    rect(xPos - 10, yPos - 10, width + 20, containerHeight, 8);
    
    // Draw LEDs
    for (int i = 0; i < count; i++) {
      leds[i].display();
    }
  }
  
  public void update() {
    // Calculate elapsed time in seconds adjusted by speed
    float elapsedSec = (millis() - startTime) / 1000.0f * stripSpeed;
    
    // Calculate animation progress factor based on playback mode
    float animFactor = 0;
    if (stripPlayback.equals("once")) {
      // For "once" mode, cap at 1.0 (100% complete)
      animFactor = min(elapsedSec * 0.2f, 1);
    } else if (stripPlayback.equals("boomerang")) {
      // For "boomerang" mode, go from 0 to 1 and back to 0
      float cycle = (elapsedSec * 0.2f) % 2;
      animFactor = cycle <= 1 ? cycle : 2 - cycle;
    } else {
      // For "loop" mode, cycle from 0 to 1 repeatedly
      animFactor = (elapsedSec * 0.2f) % 1;
    }
    
    // Update each LED in the strip
    for (int i = 0; i < count; i++) {
      updateLED(leds[i], i, animFactor, elapsedSec);
    }
  }
  
  public void updateLED(LED led, int i, float animFactor, float elapsedSec) {
    // Calculate position from 0 to 1 along the strip
    float position = count > 1 ? i / PApplet.parseFloat(count - 1) : 0.5f;
    
    // Apply different effects based on selected effect
    switch (stripEffect) {
      case "none":
        // Turn all LEDs off (black)
        led.setColor(color(0));
        break;
        
      case "solid":
        // Solid color using start color
        led.setColor(stripStartColor);
        break;
        
      case "pulse":
        // Pulse between start and end colors using sine wave
        float pulseFactor = (sin(elapsedSec) + 1) / 2; // 0 to 1
        
        // Interpolate between start and end colors
        int pulseColor = lerpColor(stripStartColor, stripEndColor, pulseFactor);
        led.setColor(pulseColor);
        break;
        
      case "linear":
        // Simplified linear fade effect for strip (always horizontal)
        
        // Apply animation offset for movement
        float shiftedPosition = (position + animFactor) % 1;
        
        // Interpolate between colors
        int linearColor = lerpColor(stripStartColor, stripEndColor, shiftedPosition);
        led.setColor(linearColor);
        break;
        
      case "constrainbow":
        // Update progress based on playback mode and speed
        if (stripPlayback.equals("once")) {
          // For "once" mode, cap progress at 1
          led.progress = min(led.progress + 0.01f * stripSpeed, 1);
        } else if (stripPlayback.equals("boomerang")) {
          // For "boomerang" mode, go back and forth
          float cyclePosition = (led.progress * 2) % 2;
          
          // Increment progress
          led.progress += 0.01f * stripSpeed;
          
          // Calculate interpolation factor based on cycle position
          float factor = cyclePosition < 1 ? cyclePosition : 2 - cyclePosition;
          
          // Interpolate RGB colors
          int interpColor = lerpColor(led.currentTargetColor, led.nextTargetColor, factor);
          led.setColor(interpColor);
          
          // If we've completed a full cycle, choose new colors
          if (led.progress >= 1) {
            int temp = led.currentTargetColor;
            led.currentTargetColor = led.nextTargetColor;
            led.nextTargetColor = randomColorBetween(stripStartColor, stripEndColor);
            led.progress = 0;
          }
          
          break;
        } else {
          // For "loop" mode, simply increment progress
          led.progress += 0.01f * stripSpeed;
        }
        
        // Check if we've reached the target
        if (led.progress >= 1) {
          // Choose new colors
          led.currentTargetColor = led.nextTargetColor;
          led.nextTargetColor = randomColorBetween(stripStartColor, stripEndColor);
          led.progress = 0;
        }
        
        // Interpolate RGB colors
        int constRainbowColor = lerpColor(led.currentTargetColor, led.nextTargetColor, led.progress);
        led.setColor(constRainbowColor);
        break;
        
      case "rainbow":
        // True rainbow effect using full HSV spectrum
        // Calculate hue based on position and time
        float position_factor = i / PApplet.parseFloat(count - 1); // Normalize to 0-1
        float hue = (position_factor + elapsedSec * stripSpeed * 0.1f) % 1;
        
        // Convert hue to RGB (full saturation and value)
        int rainbowColor = hsv2rgb(hue, 1, 1);
        led.setColor(rainbowColor);
        break;
        
      case "wipe":
        // Wipe effect: transition from start to end color horizontally
        int wipeIndex = floor(animFactor * count);
        
        // Set color based on wipe position
        if (i < wipeIndex) {
          led.setColor(stripEndColor);
        } else {
          led.setColor(stripStartColor);
        }
        break;
    }
  }
  
  public void resetColors() {
    // Reset constrainbow colors for each LED
    for (int i = 0; i < count; i++) {
      leds[i].resetConstrainbowColors();
    }
  }
}


  public void settings() { size(1080, 1100); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "costumeLighting_controls" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
